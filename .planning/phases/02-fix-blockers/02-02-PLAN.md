---
phase: 02-fix-blockers
plan: 02
type: execute
---

<objective>
Create the `/osp:component-builds` skill - a comprehensive Konflux build monitoring tool.

Purpose: Provide a single skill that can (1) check current pipeline status, (2) monitor/poll until completion, and (3) verify image freshness. This addresses the need identified after 02-01 for automated build monitoring.
Output: New skill file `commands/osp/component-builds.md` with three modes of operation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ISSUES.md
@.planning/phases/02-fix-blockers/02-01-SUMMARY.md
@.planning/phases/01-assessment/KONFLUX-FRESHNESS-REPORT.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@commands/osp/pr-pipeline-status.md
@commands/osp/release-status.md
@commands/osp/component-status.md

**From ISS-003 Requirements (expanded):**
- Check current Konflux on-push pipeline status (one-shot mode)
- Monitor/poll until all pipelines complete or timeout (watch mode)
- Verify image freshness against threshold (freshness mode)
- Accept list of repo/branch pairs or use defaults
- Use `gh api` for GitHub check runs
- Track pending, running, success, failure states
- Report clear summary with actionable next steps

**Three Modes of Operation:**
1. **status** (default): One-shot check of current pipeline status for all components
2. **watch**: Poll every 15 minutes until all complete or 3-hour timeout
3. **freshness**: Check if images are fresh (<72h) based on last successful build

**Default Components (11 total for 1.15.x):**
- tektoncd-pipeline, tektoncd-triggers, tektoncd-chains, tektoncd-results
- tektoncd-hub, tektoncd-cli, pac-downstream, tektoncd-git-clone
- console-plugin, manual-approval-gate, operator

**Existing Patterns:**
- component-status.md: Component configuration checking
- pr-pipeline-status.md: Pipeline failure diagnosis
- release-status.md: Jira issue tracking with pagination
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create component-builds.md skill file</name>
  <files>commands/osp/component-builds.md</files>
  <action>
Create a comprehensive skill file following established patterns.

**YAML Frontmatter:**
```yaml
---
name: component-builds
description: Check Konflux build status, monitor pipelines, and verify image freshness
allowed-tools:
  - Bash
  - Read
  - AskUserQuestion
---
```

**Skill Structure with Three Modes:**

1. **Objective**: Comprehensive Konflux build monitoring for release readiness

2. **Execution Context**:
   - Default components for 1.15.x release (11 components)
   - GitHub API for check runs
   - Freshness threshold: 72 hours
   - Poll interval: 15 minutes (watch mode)
   - Timeout: 3 hours (watch mode)

3. **Process Steps:**

   **Step: parse_mode** - Determine operation mode
   - `status` (default): One-shot status check
   - `watch`: Poll until completion
   - `freshness`: Verify age < 72h
   - Accept optional component list override

   **Step: define_components** - Set component list
   ```bash
   # Default 1.15.x components
   COMPONENTS=(
     "tektoncd-pipeline:release-v1.15.x"
     "tektoncd-triggers:release-v1.15.x"
     "tektoncd-chains:release-v1.15.x"
     "tektoncd-results:release-v1.15.x"
     "tektoncd-hub:release-v1.15.x"
     "tektoncd-cli:release-v1.15.x"
     "pac-downstream:release-v1.15.x"
     "tektoncd-git-clone:release-v1.15.x"
     "console-plugin:release-v1.15.x"
     "manual-approval-gate:release-v0.2.2"
     "operator:release-v1.15.x"
   )
   ```

   **Step: check_pipeline_status** - Get current status for each component
   ```bash
   for ENTRY in "${COMPONENTS[@]}"; do
     REPO="${ENTRY%%:*}"
     BRANCH="${ENTRY##*:}"

     # Get on-push pipeline status
     RESULT=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}/check-runs" \
       --jq '.check_runs[] | select(.name | contains("on-push")) | {
         name: .name,
         status: .status,
         conclusion: .conclusion,
         started_at: .started_at,
         completed_at: .completed_at
       }' 2>/dev/null | head -1)

     # Parse status
     STATUS=$(echo "$RESULT" | jq -r '.status // "unknown"')
     CONCLUSION=$(echo "$RESULT" | jq -r '.conclusion // "n/a"')

     echo "$REPO|$BRANCH|$STATUS|$CONCLUSION"
   done
   ```

   **Step: check_freshness** - Verify images are fresh
   ```bash
   THRESHOLD_HOURS=72
   NOW=$(date +%s)

   for ENTRY in "${COMPONENTS[@]}"; do
     REPO="${ENTRY%%:*}"
     BRANCH="${ENTRY##*:}"

     # Get last commit date on branch
     COMMIT_DATE=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}" \
       --jq '.commit.committer.date' 2>/dev/null)

     COMMIT_TS=$(date -d "$COMMIT_DATE" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$COMMIT_DATE" +%s 2>/dev/null)
     AGE_HOURS=$(( (NOW - COMMIT_TS) / 3600 ))

     if [[ $AGE_HOURS -lt $THRESHOLD_HOURS ]]; then
       FRESH="FRESH"
     else
       FRESH="STALE"
     fi

     echo "$REPO|$BRANCH|$COMMIT_DATE|${AGE_HOURS}h|$FRESH"
   done
   ```

   **Step: watch_mode** - Poll until all complete
   ```bash
   POLL_INTERVAL=900  # 15 minutes
   MAX_WAIT=10800     # 3 hours
   START_TIME=$(date +%s)

   while true; do
     # Check all components
     PENDING=0
     PASSED=0
     FAILED=0

     for ENTRY in "${COMPONENTS[@]}"; do
       REPO="${ENTRY%%:*}"
       BRANCH="${ENTRY##*:}"

       STATUS=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}/check-runs" \
         --jq '.check_runs[] | select(.name | contains("on-push")) | .status' 2>/dev/null | head -1)
       CONCLUSION=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}/check-runs" \
         --jq '.check_runs[] | select(.name | contains("on-push")) | .conclusion' 2>/dev/null | head -1)

       if [[ "$STATUS" == "completed" ]]; then
         [[ "$CONCLUSION" == "success" ]] && ((PASSED++)) || ((FAILED++))
       else
         ((PENDING++))
       fi
     done

     echo "Status: $PASSED passed, $FAILED failed, $PENDING pending"

     # Exit conditions
     [[ $PENDING -eq 0 ]] && echo "All pipelines complete!" && break

     ELAPSED=$(($(date +%s) - START_TIME))
     [[ $ELAPSED -ge $MAX_WAIT ]] && echo "Timeout after 3 hours" && break

     echo "Next check in 15 minutes... (${ELAPSED}s elapsed)"
     sleep $POLL_INTERVAL
   done
   ```

   **Step: display_results** - Format output table
   ```markdown
   ## Component Build Status

   **Mode:** {status|watch|freshness}
   **Checked at:** {timestamp}

   | Component | Branch | Status | Conclusion | Age |
   |-----------|--------|--------|------------|-----|
   | tektoncd-pipeline | release-v1.15.x | completed | success | 2h |
   | ... | ... | ... | ... | ... |

   **Summary:** X passed, Y failed, Z pending

   ### Action Required
   [List any failed or stale components with `/osp:pr-pipeline-status` commands]
   ```

4. **Output**: Status table with pass/fail/pending counts
5. **Success Criteria**: All components checked, clear summary provided
  </action>
  <verify>
```bash
# Verify file structure
head -15 commands/osp/component-builds.md
grep -c "<step name=" commands/osp/component-builds.md
```
  </verify>
  <done>Skill file created with all three modes (status, watch, freshness)</done>
</task>

<task type="auto">
  <name>Task 2: Test skill with current pipeline data</name>
  <files>None (testing only)</files>
  <action>
Run a real status check to validate the skill logic works:

1. **Test status mode (one-shot check):**
```bash
echo "| Component | Branch | Status | Conclusion |"
echo "|-----------|--------|--------|------------|"

COMPONENTS=(
  "tektoncd-pipeline:release-v1.15.x"
  "tektoncd-triggers:release-v1.15.x"
  "tektoncd-chains:release-v1.15.x"
  "tektoncd-results:release-v1.15.x"
  "tektoncd-hub:release-v1.15.x"
  "tektoncd-cli:release-v1.15.x"
  "pac-downstream:release-v1.15.x"
  "tektoncd-git-clone:release-v1.15.x"
  "console-plugin:release-v1.15.x"
  "manual-approval-gate:release-v0.2.2"
  "operator:release-v1.15.x"
)

for ENTRY in "${COMPONENTS[@]}"; do
  REPO="${ENTRY%%:*}"
  BRANCH="${ENTRY##*:}"

  RESULT=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}/check-runs" \
    --jq '.check_runs[] | select(.name | contains("on-push")) | "\(.status)|\(.conclusion // "n/a")"' 2>/dev/null | head -1)

  STATUS=$(echo "$RESULT" | cut -d'|' -f1)
  CONCLUSION=$(echo "$RESULT" | cut -d'|' -f2)
  [[ -z "$STATUS" ]] && STATUS="no-runs" && CONCLUSION="n/a"

  echo "| $REPO | $BRANCH | $STATUS | $CONCLUSION |"
done
```

2. **Test freshness mode:**
```bash
echo "| Component | Branch | Last Commit | Age | Status |"
echo "|-----------|--------|-------------|-----|--------|"

NOW=$(date +%s)
THRESHOLD=72

for ENTRY in "${COMPONENTS[@]}"; do
  REPO="${ENTRY%%:*}"
  BRANCH="${ENTRY##*:}"

  COMMIT_DATE=$(gh api "repos/openshift-pipelines/${REPO}/commits/${BRANCH}" \
    --jq '.commit.committer.date' 2>/dev/null)

  # macOS compatible date parsing
  if [[ "$(uname)" == "Darwin" ]]; then
    COMMIT_TS=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$COMMIT_DATE" +%s 2>/dev/null || echo "0")
  else
    COMMIT_TS=$(date -d "$COMMIT_DATE" +%s 2>/dev/null || echo "0")
  fi

  AGE_HOURS=$(( (NOW - COMMIT_TS) / 3600 ))
  [[ $AGE_HOURS -lt $THRESHOLD ]] && FRESH="FRESH" || FRESH="STALE"

  echo "| $REPO | $BRANCH | $COMMIT_DATE | ${AGE_HOURS}h | $FRESH |"
done
```

3. **Verify skill file is discoverable:**
```bash
ls -la commands/osp/component-builds.md
```

Record the actual output - this shows current state of all 11 components.
  </action>
  <verify>
- gh api calls succeed for all 11 components
- Status table shows real data
- Freshness calculation works (age in hours)
- No API errors or authentication issues
  </verify>
  <done>Skill validated with real pipeline data, all 11 components checked</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `commands/osp/component-builds.md` exists with proper structure
- [ ] YAML frontmatter has name, description, allowed-tools
- [ ] Three modes documented: status, watch, freshness
- [ ] Process has steps for each mode
- [ ] gh api calls work for all 11 components
- [ ] Output format matches other skills (markdown table)
- [ ] Real status check completed and recorded
</verification>

<success_criteria>

- New skill file created at `commands/osp/component-builds.md`
- Supports three modes: status (one-shot), watch (poll), freshness (age check)
- Works with all 11 components for 1.15.x release
- Follows established codebase conventions
- ISS-003 can be marked resolved
</success_criteria>

<output>
After completion, create `.planning/phases/02-fix-blockers/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Create /osp:component-builds Skill Summary

**[One-liner: Created comprehensive Konflux build monitoring skill with status/watch/freshness modes]**

## Accomplishments

- Created `commands/osp/component-builds.md` skill
- Implements three modes:
  - `status`: One-shot pipeline status check
  - `watch`: Poll every 15 min until complete (3hr timeout)
  - `freshness`: Verify images are fresh (<72h)
- Covers all 11 components for 1.15.x release

## Files Created

- `commands/osp/component-builds.md` - Comprehensive build monitoring skill

## Current Build Status

[Include actual status from Task 2 verification]

| Component | Branch | Status | Conclusion | Age |
|-----------|--------|--------|------------|-----|
| ... | ... | ... | ... | ... |

**Summary:** X passed, Y failed, Z pending, W fresh, V stale

## Issues Resolved

- ISS-003: Create /osp:wait-for-builds skill - CLOSED (implemented as /osp:component-builds)

## Next Step

Ready for 02-03: Diagnose PR #903 Konflux failure
Run: `/gsd:execute-plan .planning/phases/02-fix-blockers/02-03-PLAN.md`
</output>
